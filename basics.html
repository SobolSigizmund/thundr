---
layout: default
title: thundr
id: basics
---
<div class="page-header">
  <h1>thundr <small>basics</small></h1>
</div>
<section class="overview">
	<h2>Overview</h2>
	<p>
		thundr, like most other web frameworks, uses the <em>Model-View-Controller</em>,
		or <a href="http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">MVC</a>,
		pattern for separation of concerns between data processing and view presentation.
	</p>
	<p>
		In this pattern, the model and the view and the relationship between them is mediated by a controller.
	</p>
	<p>
		In thundr, this control is enacted by the method invoked inside your controller class. <a href="/controllers.html">more</a><br/>
		The view is represented by a <code>View</code> object, which is the return type of the controller method. <a href="/views.html">more</a><br/> 
		The model is provided to the view by the controller method, but the requirements of this depend on the type of view.
	</p>
</section>
<section id="basicExample">
<h4>Basic Example</h4>
<figure>
	<figcaption>Routes file - routes.json <a href="/actions.html#routes">more</a></figcaption>
<pre>
{
	"/"		: "com.threewks.web.Controller.home"
}
</pre>
</figure>
<figure>
	<figcaption>Controller - Controller.java <a href="/controllers.html#overview">more</a></figcaption>
<pre>
package com.threewks.web;

import java.util.HashMap;
import java.util.Map;
import com.threewks.thundr.view.jsp.JspView;

public class Controller {
	public JspView home() {
		Map&lt;String, Object&gt; model = new HashMap&lt;String, Object&gt;();
		model.put("message", "Hello World!");
		return new JspView("home.jsp", model);
	}
}
</pre>
</figure>
<figure>
<figcaption>Jsp - /WEB-INF/jsp/home.jsp <a href="/views.html#jspView">more</a></figcaption>
<pre>
&lt;%@ page contentType="text/html" pageEncoding="UTF-8"%&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
	&lt;head&gt;
		&lt;meta charset="utf-8" lang="en-us"/&gt;
	&lt;/head&gt;
	&lt;body&gt;
		\${message}
	&lt;/body&gt;
&lt;/html&gt;
</pre>
</figure>
<p>
	With these three files, if you were to visit the url <code>http://localhost:8080/</code> you would be served a page
	with the content 'Hello World!'.
</p>
<p>
	We can see the basics of thundr and the three elements of the MVC interacting here:
</p>
<ol>
	<li>an incoming request is mapped to a controller using a <a href="/actions.html#routes">route</a></li>
	<li>Our <a href="/controllers.html">controller</a> method populates the <strong>model</strong> map with our message,</li>
	<li>which is then provided to our <a href="/views.html">view</a>, a JspView.<br/></li>
	<li>thundr takes care of the rest, serving up our jsp as html, substituting the el variable \${message} with the text 'Hello World!'.</li>
</ol>
</section>
<section id="applicationConfiguration">
	<h4>Application Configuration</h4>
	
	<p>
		Beyond the basics of controller invocation and returning a view, there are several elements of configuration required for
		a thundr based application.
	</p>
	<ul>
		<li><a href="#webXml">web.xml</a> - configuring the thundr servlet</li>
		<li><a href="#modulesProperties">modules.properties</a> - defining the thundr modules in use</li>
		<li><a href="#injectionConfiguration">InjectionConfiguation</a> - your dependency injection configuration</li>
		<li><a href="#applicationProperties">application properties</a> - your environmental properties</li>
	</ul>
</section>
<section id="webXml">
	<h4><code>web.xml</code></h4>

	<p>
		The minimum web.xml required for a thundr app is to include the thundr servlet.
	</p>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app
	xmlns="http://java.sun.com/xml/ns/javaee"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
	version="2.5"&gt;
<%-- TODO - its not clear how much we rely on this atm, i'm pretty sure not really at all
	<listener> <listener-class>com.threewks.thundr.view.jsp.RegisterElResolverServletContextListener</listener-class> </listener>--%>
	&lt;servlet&gt;
		&lt;servlet-name&gt;servlet&lt;/servlet-name&gt;
		&lt;servlet-class&gt;com.threewks.thundr.WebFrameworkServlet&lt;/servlet-class&gt;
		&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
	&lt;/servlet&gt;
	&lt;servlet-mapping&gt;
		&lt;servlet-name&gt;servlet&lt;/servlet-name&gt;
		&lt;url-pattern&gt;/&lt;/url-pattern&gt;
	&lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</pre>
	<p>
		Beyond this, you can use any servlets, servlet filters or other web.xml features you want. Remember that thundr is 
		capable of invoking a servlet as a controller if you so wish. 
	</p>
</section>
<section id="#modulesProperties">
	<h4><code>modules.properties</code></h4>
	
	<p>
		thundr is extensible, it allows extra features and components to be added to applications. 
		These components are called <strong>modules</strong>.
	</p>
	<p>
		Modules are configured by adding them to resource <em>modules.properties</em>.
	</p>
	<p>
		This file is a standard java properties file, where only the key values are of interest.<br/>
		Each entry causes a module to be loaded. The minimum modules file only needs to contain the 
		package for the module which is the application.
	</p>
<figure>
<figcaption>for the application defined in com.mycompany.myapp - modules.properties</figcaption>
<pre>
com.mycompany.myapp=
</pre>
</figure>
	<div class="alert alert-info">
		The order of modules in this file is significant, you should always put your application module at the top.
	</div>
</section>
<section id="injectionConfiguration">
	<h4><code>InjectionConfiguration</code></h4>
	
	<p>
		A module is defined as a group of code and an <code>InjectionConfiguration</code> file.
	</p>
	<p>
		You application uses an InjectionConfiguration to make available all the instances and classes you wish to inject into your
		controllers and each-other
	</p>
	<p>
		Your injection configuration needs to implement <code>com.threewks.thundr.injection.InjectionConfiguration</code>. 
		It also has to have a specific name, which is <strong>X</strong>InjectionConfiguration where <strong>X</strong> is the
		name of the package it resides in.  
	</p>
	<p>
		For example, if your injection configuration is in the package <code>com.mycompany.myapp</code>, your
		configuration must be the java class <code>com.mycompany.myapp.MyappInjectionConfiguration</code>. In this case,
		your <em>module</em> will be com.mycompany.myapp.
	</p>
<figure>
<figcaption>com.mycompany.myapp.MyappInjectionConfiguration</figcaption>
<pre>
package com.mycompany.myapp;

import com.threewks.thundr.injection.BaseInjectionConfiguration;
import com.threewks.thundr.injection.InjectionConfiguration;
import com.threewks.thundr.injection.UpdatableInjectionContext;
import com.threewks.thundr.profiler.BasicProfiler;
import com.threewks.thundr.profiler.Profiler;

public class MyappInjectionConfiguration implements InjectionConfiguration {

	@Override
	public void configure(UpdatableInjectionContext injectionContext) {
		injectionContext.inject(MyServiceImpl.class).as(MyServiceInterface.class);
		injectionContext.inject(MyRepositoryImpl.class).as(MyRepositoryInterface.class);
	}
}
</pre>
</figure>
	<p>
		<div class="alert alert-info">
			The naming rules for an InjectionConfiguration are case sensitive! My<strong>a</strong>ppInjectionConfiguration is not the same as My<strong>A</strong>ppInjectionConfiguration.
		</div>
		Rather than implement <code>InjectionConfiguration</code>, you can also extend <code>BaseInjectionConfiguration</code>
		for convenience.
	</p>
</section>
<section id="applicationProperties">
	<h4><code>application.properties</code></h4>
	
	<p>
		thundr automatically loads properties from the <code>application.properties</code> file and puts them as named strings
		into the InjectionContext. This makes them available both in your InjectionConfiguration and also as constructor arguments
		to injected dependencies.  
	</p>
	<p>
		This file is suitable for specifying configuration values that change per environment. That is, while all the other
		configuration is generally environmentally agnostic, the application properties will generally not be. 
	</p>
	<p>
		This allows your built war file to be portable through environments without requiring rebuilding.
	</p>
<pre>
threadCount=20
threadCount%dev=2
serverUrl=localhost:8080
serverUrl%production=www.production.com
</pre>
	<p>
		In the above example, all environments will have the properties <em>threadCount</em> and <em>serverUrl</em> injected into them,
		but the serverUrl for the environment named 'production' will be different.<br/>
		<div class="alert alert-info">
			The environment named 'dev' is special, in that it specifically applies to local development, rather than a target deployment environment.
		</div>
	</p>	
</section>