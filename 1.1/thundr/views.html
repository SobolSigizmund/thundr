---
layout: 1.1/base
title: Views
description: Using views in thundr
---

<div class="row">
	<aside class="module_nav_container col-md-3">
		<div class="module_nav">
			<ul class="nav nav-pills nav-stacked" role="navigation">
				<li class="nav-header ">
					<a href="{{ site.url }}/1.1/thundr/basics.html">
						Basics
					</a>
				</li>

				<li class="nav-header ">
					<a href="{{ site.url }}/1.1/thundr/controllers.html">
						Controllers
					</a>
				</li>

				<li class="nav-header active">
					<a href="{{ site.url }}/1.1/thundr/views.html">
						Views
					</a>
				</li>

				<li>
					<a href="{{ site.url }}/1.1/thundr/views.html#views" data-target="#views">
						Views
					</a>
				</li>
				
				<li>
					<a href="{{ site.url }}/1.1/thundr/views.html#templateView" data-target="#templateView">
						TemplateView
					</a>
				</li>
				
				<li>
					<a href="{{ site.url }}/1.1/thundr/views.html#dataView" data-target="#dataView">
						DataView
					</a>
				</li>
				
				<li>
					<a href="{{ site.url }}/1.1/thundr/views.html#baseView" data-target="#baseView">
						BaseView
					</a>
				</li>
				
				<li class="divider"></li>
				

				<li>
					<a href="{{ site.url }}/1.1/thundr/views.html#jspView" data-target="#jspView">
						JspView
					</a>
				</li>

				<li>
					<a href="{{ site.url }}/1.1/thundr/views.html#redirectView" data-target="#redirectView">
						RedirectView
					</a>
				</li>
				<li>
					<a href="{{ site.url }}/1.1/thundr/views.html#routeRedirectView" data-target="#routeRedirectView">
						RouteRedirectView
					</a>
				</li>

				<li>
					<a href="{{ site.url }}/1.1/thundr/views.html#jsonView" data-target="#jsonView">
						JsonView
					</a>
				</li>

				<li>
					<a href="{{ site.url }}/1.1/thundr/views.html#stringView" data-target="#stringView">
						StringView
					</a>
				</li>
				
				<li>
					<a href="{{ site.url }}/1.1/thundr/views.html#httpStatusException" data-target="#httpStatusException">
						HttpStatusException
					</a>
				</li>

				<li>
					<a href="{{ site.url }}/1.1/thundr/views.html#negotiatingView" data-target="#negotiatingView">
						NegotiatingView
					</a>
				</li>

				<li class="divider"></li>
				
				<li>
					<a href="{{ site.url }}/1.1/thundr/views.html#globalModel" data-target="#globalModel">
						Global Model
					</a>
				</li>
				<li>
					<a href="{{ site.url }}/1.1/thundr/views.html#viewResolver" data-target="#viewResolver">
						ViewResolver <span class="label label-info">Advanced</span>
					</a>
				</li>

				<li class="nav-header ">
					<a href="{{ site.url }}/1.1/thundr/actions.html">
						Routes and Actions
					</a>
				</li>

				<li class="nav-header ">
					<a href="{{ site.url }}/1.1/thundr/modules.html">
						Modules
					</a>
				</li>

				<li class="nav-header ">
					<a href="{{ site.url }}/1.1/thundr/jsp.html">						
						Jsp						
					</a>
				</li>
	
				<li class="nav-header ">
					<a href="{{ site.url }}/1.1/thundr/email.html">
						Email
					</a>
				</li>
				
				<li class="nav-header ">
					<a href="{{ site.url }}/1.1/thundr/utilities.html">
						Utilities
					</a>
				</li>
				<li class="nav-header ">
					<a href="{{ site.url }}/1.1/thundr/glossary.html">
						Glossary
					</a>
				</li>
			</ul>
		</div>
	</aside>

	<article id="views" class="col-md-9">
		<div class="page-header">
			<h1>thundr <small>views</small></h1>
		</div>

		<section id="page-overview" class="overview">
		</section>

		<section id="views">
			<h4>Views</h4>

			<p><a href="{{ site.url }}/1.1/thundr/controllers.html">Controller</a> methods can return a <code>View</code> object, which
				controls what content is returned to the request client.</p>

			<p>thundr handles views by passing them to registered a <code>ViewResolver</code>. You can read more about
				registering custom view and view resolvers <a href="{{ site.url }}/1.1/thundr/views.html#viewResolver">here</a>.</p>

			<p>Below are the views that thundr supports out of the box. You can also inspect the ViewResolver hierarchy to see
				all implementations.
			</p>
			
			<p>
				Views broadly fall into two categories - <a href="#templateView">template views</a> and <a href="#dataView">data views</a>.
			</p>
		</section>
		
		<section id="templateView">
			<h4><code>TemplateView</code></h4>
			<p>
				Template views are views that combine a data model with a templating engine to produce output. Examples of this
				are jsps and handlebars. The template controls the appearance of the output, and includes dynamic content
				from the model. Most frequently, this is used to generate html output, but can be used to produce other content as well.
			</p>
		</section>
		
		<section id="dataView">
			<h4><code>DataView</code></h4>
			<p>
				Data views are views that transform a data model to a data format. The difference between data views and template views is
				that the output format is automatic and requires no template. Examples of data views are xml or json representations of java
				objects.
			</p>
			<p>
				The <code>DateView</code> itself is a base class that can be extended to build a data based view quickly and make it easily work
				with the <a href="#negotiatingView">content negotiation</a> feature of thudnr.
			</p>
		</section>

		<section id="baseView">
			<h4><code>BaseView</code></h4>
			<p>
				The BaseView is a base view class that provides common behaviour to View implementations.
				All of the view types below (with the exception of the HttpStatusException) implement the base view.
			</p>
			<p>
				This provides a common interface to add additional information to the response.
			</p>
{% highlight java %}
...
return new StringView("Hello!")
	.withStatus(StatusCode.BadRequest)
	.withHeader(HttpSupport.Header.ContentType, "text/plain")
	.withCookie("user", userId);
...
{% endhighlight %}			
		</section>
		
		
		<h4>View types</h4>
		<section id="jspView" class="panel panel-default">
  			<div class="panel-heading">
    			<h4 class="panel-title">
    				<a data-toggle="collapse"  href="#jspViewInner">
						JspView
						<i class="fa fa-minus-circle pull-right"></i>
					</a>
				</h4>
			</div>

			<div id="jspViewInner" class="panel-collapse collapse in">
     		 	<div class="panel-body">
					<p><code>JspView</code> results in a jsp being processed and served from the Servlet engine. You specify
						the jsp file location, and optionally provide a data model to back it. Unless the jsp rendering
						fails, an Html file and a 200 OK will be sent back to the user. </p>

					<p>The jsp file is considered to be relative to the path /WEB-INF/jsp/, unless it is given as an
						absolute path (i.e. starts with a forward slash, /)</p>

{% highlight java %}
...
Map<String, Object> model = ... 
return new JspView("path/to/my.jsp", model);
...
{% endhighlight %}
					<blockquote>
					The model passed into the view will be enhanced with all request attributes and the <a href="#globalModel">global model</a> when the view is rendered.
					This means you can access any request attributes or entries in the globabl model in you jsp using EL, without
					adding them by hand to your model.
					</blockquote>
					<p>
						You can read more about thundr support for jsps <a href="jsp.html">here</a>.
					</p>
					</div>
			</div>
		</section>

		<section id="redirectView" class="panel panel-default">
  			<div class="panel-heading">
    			<h4 class="panel-title">
    				<a data-toggle="collapse"  href="#redirectViewInner">
						RedirectView
						<i class="fa fa-minus-circle pull-right"></i>
					</a>
				</h4>
			</div>

			<div id="redirectViewInner" class="panel-collapse collapse in">
     		 	<div class="panel-body">
					<p><code>RedirectView</code> results in a temporary redirect (302) being sent back to the client with
						the specified location. This will send a browser to the new url.</p>

{% highlight java %}
...
return new RedirectView("http://www.google.com.au/search?q=thundr");
...
{% endhighlight %}
				</div>
			</div>
		</section>
		
		<section id="routeRedirectView" class="panel panel-default">
  			<div class="panel-heading">
    			<h4 class="panel-title">
    				<a data-toggle="collapse"  href="#routeRedirectViewInner">
						RouteRedirectView
						<i class="fa fa-minus-circle pull-right"></i>
					</a>
				</h4>
			</div>

			<div id="routeRedirectViewInner" class="panel-collapse collapse in">
     		 	<div class="panel-body">
					<p><code>RouteRedirectView</code> results in a temporary redirect (302) being sent back to the client. 
					The location is generated to match whatever the specified route has as a url.
					This will send a browser to the new url.
					</p>
					<p> If we assume the following route was configured:</p>
{% highlight java %}
...
routes.addRoute(RouteType.GET, "/users/{userId}/view", "UserView", new MethodAction(UserController.class, "view"));
...
{% endhighlight %}
					<p>Then this would result in a redirect to '/user/1234/view'</p>
{% highlight java %}
...
Map<String, Object> pathVariables = map("userId", 1234);
return new RouteRedirectView("UserView", pathVariables);
...
{% endhighlight %}
					<p>
					The RouteRedirectView decouples the redirect from the configured route. This makes it easier to change/refactor routes
					without needing to search/replace in your code base.
					</p> 
				</div>
			</div>
		</section>
		
		<section id="jsonView" class="panel panel-default">
  			<div class="panel-heading">
    			<h4 class="panel-title">
    				<a data-toggle="collapse"  href="#jsonViewInner">
						JsonView
						<i class="fa fa-minus-circle pull-right"></i>
					</a>
				</h4>
			</div>
			<div id="jsonViewInner" class="panel-collapse collapse in">
     		 	<div class="panel-body">
					<p><code>JsonView</code> uses the <a href="http://code.google.com/p/google-gson/">Gson library</a> to
						serialize the given object to json, and return it to the request client.</p>

{% highlight java %}
...
MyDto dto = ... 
return new JsonView(dto);
...
{% endhighlight %}
				</div>
			</div>
		</section>


		<section id="stringView" class="panel panel-default">
  			<div class="panel-heading">
    			<h4 class="panel-title">
    				<a data-toggle="collapse"  href="#stringViewInner">
						StringView
						<i class="fa fa-minus-circle pull-right"></i>
					</a>
				</h4>
			</div>

			<div id="stringViewInner" class="panel-collapse collapse in">
     		 	<div class="panel-body">
					<p>
						<code>StringView</code> is a simple view which returns the given string as the response content, with
						a response code of 200 OK and a content type of text/plain.
					</p>

{% highlight java %}
...
return new StringView("Hello!");
...
{% endhighlight %}
				</div>
			</div>
		</section>
		
		<section id="httpStatusException" class="panel panel-default">
  			<div class="panel-heading">
    			<h4 class="panel-title">
    				<a data-toggle="collapse"  href="#httpStatusExceptionInner">
						HttpStatusException
						<i class="fa fa-minus-circle pull-right"></i>
					</a>
				</h4>
			</div>

			<div id="httpStatusExceptionInner" class="panel-collapse collapse in">
     		 	<div class="panel-body">
					<p><code>HttpStatusException</code> is a RuntimeException which takes a status code as a constructor
						parameter.</p>

					<p>When thrown, the specified status code is returned to the client as an http error, along with the
						specified message.</p>

{% highlight java %}
...
throw new HttpStatusException(HttpServletResponse.SC_BAD_REQUEST, "Bad request at %d", System.currentTimeMillis());
...
{% endhighlight %}

					<p>The servlet engine will process the response code as normal, so if your web.xml maps a jsp, then this
						is the content returned to the client. e.g.</p>

{% highlight xml %}				
...
<error-page>
    <error-code>404</error-code>
    <location>/WEB-INF/jsp/errors/404.jsp</location>
</error-page>
...
{% endhighlight %}
				</div>
			</div>
		</section>
		
		<section id="negotiatingView" class="panel panel-default">
  			<div class="panel-heading">
    			<h4 class="panel-title">
    				<a data-toggle="collapse"  href="#negotiatingViewInner">
						NegotiatingView
						<i class="fa fa-minus-circle pull-right"></i>
					</a>
				</h4>
			</div>

			<div id="negotiatingViewInner" class="panel-collapse collapse in">
     		 	<div class="panel-body">
					<p>
						<code>NegotiatingView</code> is a data view which determines the content type using content negotiation techniques.
					</p>
					<p>
						This is useful when you want to provide an API that serves up content in a format chosen by the consumer.
					</p>
{% highlight java %}
...
return new NegotiatingView(pojo);
...
{% endhighlight %}					
					<p>
						Negotiation works out of the box for included data views (i.e. JsonView), and any modules which add new data views
						will typically just work.
					</p>
					<p>
						Content negotiation relies on delegation to another <code>View</code> type which is determined by the http request.
						The <code>NegotiatingView</code> is converted into another <code>DataView</code> using a <code>Negotiator</code>, which
						then is resolved as normal.
					</p>
					<p>
						Negotiators are registered with the <code>ViewNegotiatorRegistry</code> in the application module at startup. 
						When you register a negotiator, you specify the content type that it should be used for. When a request is determined
						to be requesting that content type, the Negotiator will convert the NegotiatingView and resolve using the desired
						View implementation.
					</p>
					<p>
						The content type that is desired for a particular request is determined by a series of <code>NegotiationStrategy</code> instances.
						You can add and remove negotiation strategies on the <code>NegotiatingViewResolver</code> directly. In this way you can tweak
						the factors that are used to detemine the desired output content type.
					</p>
					<p>
						By default, the following strategies are used in order to determine the desired output content type:
					</p>
					<ul>
						<li>
							<code>ContentTypeNegotiationStrategy</code> - if the NegotiatingView has a content type specified it will be used (e.g. <code>new NegotiatingView(data).withContentType("mime/type")</code>)
						</li>
						<li>
							<code>FileExtensionNegotiationStrategy</code> - looks for a file extension on the request (e.g. http://www.myserver.com/path/file<strong>.html</strong> )
						</li>
						<li>
							<code>AcceptsHeaderNegotiationStrategy</code> - looks at the Accept Header to determine content type (Check out the RFC here: <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>)
						 </li>
						<li>
							<code>DefaultNegotiatorNegotiationStrategy</code> - relies on the default value set on the <code>ViewNegotiatorRegistry</code>
						</li>
					</ul>
				</div>
			</div>
		</section>

		<section id="globalModel">
			<h4><code>GlobalModel</code></h4>

			<p>The <code>GlobalModel</code> is a data model which allows you to provide data into all <code>TemplateView</code>
			implementations without needing to add them in every controller. This is very useful for cross cutting needs.
			</p>
			<p>
			The global model is configured at startup in your <a href="{{ site.url }}/1.1/thundr/basics.html#applicationModule">ApplicationModule</a>.
			</p>
{% highlight java %}
public class ApplicationModule implements Module {
...
	@Override
	public void configure(UpdatableInjectionContext injectionContext) {
		super.configure(injectionContext);
		GlobalModel globalModel = injectionContext.get(GlobalModel.class);
		String applicationUrlFromApplicationProperties = injectionContext.get("applicationUrl")
		globalModel.put("applicationUrl", applicationUrlFromApplicationProperties);
		...
{% endhighlight %}
			<p>
				In this example, the value configured in the application.properties file will now be available in
				all template views (e.g. <a href="#jspView">JspView</a>, <a href="{{ site.url }}/1.1/thundr-handlebars/index.html#handlebarsView">HandlebarsView</a> etc). We could then use it as follows:
			</p>	
{% highlight jsp %}
...
	<a href="${applicationUrl}/path/to/awesome.page">It's awesome!</a>
...
{% endhighlight %}
			<blockquote>
				The <code>GlobalModel</code> can be very powerful if you put a factory class or lookup implementation in it.
				For example, you could include a wrapper around a ThreadLocal containing the logged in user, or a factory that
				looks up request based reference data.  
			</blockquote>					
			<div class="alert alert-warning">
				Remember that the GlobalModel is a <strong>global model</strong> - it is shared by all views, and should only be
				used in a stateless capacity. If you alter it at runtime, particularly in a request, then you are doing something wrong.
			</div>
		</section>
		<section id="viewResolver">
			<h4><code>ViewResolver</code> <span class="label label-info">Advanced</span></h4>

			<p>
			Every type of <code>View</code> is rendered by a <code>ViewResolver</code>. You can create your own views just by implementing 
			a ViewResolver and registering it with thundr at startup.
			</p>
{% highlight java %}
public class ApplicationModule implements Module {
...
  @Override
  public void configure(UpdatableInjectionContext injectionContext) {
    super.configure(injectionContext);
    ViewResolverRegistry viewResolverRegistry = injectionContext.get(ViewResolverRegistry.class);
    viewResolverRegistry.addResolver(MyView.class, new MyViewResolver());
    ...
{% endhighlight %}			
			<p>
			You can register <em>any</em> class as a view, it doesn't need to implement the <code>View</code> interface, or extend <code>BaseView</code>.
			This means you can register any of your application model classes, any exception type or any other class for that matter.
			That is, while most views do implement the <code>View</code> interface, this is for convenience and not a requirement.
			</p>		
			<p>
				At runtime, thundr will look at the type of the view returned from a controller method and find the appropriate <code>ViewResolver</code> in 
				the <code>ViewResolverRegistry</code>.
			</p>
			<p>
				The view resolver is then given the view instance, the servlet request and
				servlet response and is expected to generate some output to the servlet response.
			</p>
			<blockquote>
				If you're implementing a <code>ViewResolver</code> for sharing in a module, use the following guidelines:
				<ul>
					<li>
						Implement the <code>View</code> interface. This allows controllers to return View, rather than Object when they mix return types
					</li>
					<li>
						Extend <code>BaseView</code> and in your view resolver call the <code>BaseView.applyToResponse</code> method. This allows consumers to use a consistent interface. This may not always be appropriate, but usually is.
					</li>
					<li>
						If you're writing a template style view (e.g. Jsp, Handlebars, Mustache, Freemarker etc) make sure you allow consumers to specify a model, and also include the global model.
					</li>
					<li>
						If you're writing a data style view (e.g. Json, Xml etc) consider writing a <a href="{{ site.url }}/1.1/thundr/controllers.html#parameterBinding">ParameterBinder or BinaryParameterBinder</a> so that the same representation can be consumed by controllers.
					</li>
				</ul>
			</blockquote>
		</section>
		<hr/>
		<section>
		<a href="actions.html">Routes and actions</a> are up next.
		</section>
	</article>
</div>
		