---
layout: 1.0/base
versionUrl: /1.0
title: Basics
description: thundr framework basics
---

<div class="row">
<aside class="module_nav_container col-md-3">
	<div class="module_nav">
		<ul class="nav nav-pills nav-stacked" role="navigation">
			<li class="nav-header active">
				<a href="{{ site.url }}{{ page.versionUrl }}/thundr/basics.html">
					Basics
				</a>
			</li>

			<li>
				<a href="{{ site.url }}{{ page.versionUrl }}/thundr/basics.html#page-overview" data-target="#page-overview">
					Overview
				</a>
			</li>

			<li class="divider"></li>

			<li>
				<a href="{{ site.url }}{{ page.versionUrl }}/thundr/basics.html#basicExample" data-target="#basicExample">
					Basic Example
				</a>
			</li>


			<li>
				<a href="{{ site.url }}{{ page.versionUrl }}/thundr/basics.html#applicationConfiguration" data-target="#applicationConfiguration">
					Configuration
				</a>
			</li>

			<li class="divider"></li>

			<li>
				<a href="{{ site.url }}{{ page.versionUrl }}/thundr/basics.html#webXml" data-target="#webXml">
					web.xml
				</a>
			</li>

			<li>
				<a href="{{ site.url }}{{ page.versionUrl }}/thundr/basics.html#applicationModule" data-target="#applicationModule">
					ApplicationModule
				</a>
			</li>
			<li>
				<a href="{{ site.url }}{{ page.versionUrl }}/thundr/basics.html#routes" data-target="#routes">
					Routes
				</a>
			</li>

			<li>
				<a href="{{ site.url }}{{ page.versionUrl }}/thundr/basics.html#applicationProperties" data-target="#applicationProperties">
					application.properties
				</a>
			</li>
			<li>
				<a href="{{ site.url }}{{ page.versionUrl }}/thundr/basics.html#platforms" data-target="#platforms">
					Platforms
				</a>
			</li>

			<li class="nav-header ">
				<a href="{{ site.url }}{{ page.versionUrl }}/thundr/controllers.html">
					Controllers
				</a>
			</li>

			<li class="nav-header ">
				<a href="{{ site.url }}{{ page.versionUrl }}/thundr/views.html">
					Views
				</a>
			</li>

			<li class="nav-header ">
				<a href="{{ site.url }}{{ page.versionUrl }}/thundr/actions.html">
					Routes and Actions
				</a>
			</li>

			<li class="nav-header ">
				<a href="{{ site.url }}{{ page.versionUrl }}/thundr/modules.html">
					Modules
				</a>
			</li>

			<li class="nav-header ">
				<a href="{{ site.url }}{{ page.versionUrl }}/thundr/jsp.html">						
					Jsp						
				</a>
			</li>

			<li class="nav-header ">
				<a href="{{ site.url }}{{ page.versionUrl }}/thundr/email.html">
					Email
				</a>
			</li>
			
			<li class="nav-header ">
				<a href="{{ site.url }}{{ page.versionUrl }}/thundr/utilities.html">
					Utilities
				</a>
			</li>
			<li class="nav-header ">
				<a href="{{ site.url }}{{ page.versionUrl }}/thundr/glossary.html">
					Glossary
				</a>
			</li>			
		</ul>
	</div>
</aside>

<article id="basics" class="col-md-9">
	<div class="page-header">
		<h1>thundr
			<small>basics</small>
		</h1>
	</div>

	<section id="page-overview" class="overview">
		<h2>Overview</h2>

		<p>
			thundr, like most other web frameworks, uses the <em>Model-View-Controller</em>, or 
			<a href="http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">MVC</a>, pattern for
			separation of concerns between data processing and view presentation.
		</p>

		<p>
			In this pattern, the model and the view and the relationship between them is mediated by a controller.
		</p>

		<p>
			In thundr, this control is enacted by the method invoked inside your controller class. 
			<a href="{{ site.url }}{{ page.versionUrl }}/thundr/controllers.html">more</a><br/>
			The view is represented by a <code>View</code> object, which is the return type of the controller method. 
			<a href="{{ site.url }}{{ page.versionUrl }}/thundr/views.html">more</a><br>
			The model is provided to the view by the controller method, but the requirements of this depend on the type 
			of view.
		</p>
	</section>

	<section id="basicExample">
		<h4>Basic Example</h4>

		<p>Given the following Controller and View implementations, we can see the basics of how thundr would render a page</p>

		<p>Controller - Controller.java <a href="{{ site.url }}{{ page.versionUrl }}/thundr/controllers.html">more</a></p>

{% highlight java %}
package com.threewks.web;

import java.util.HashMap;
import java.util.Map;
import com.threewks.thundr.view.jsp.JspView;

public class Controller {
    public JspView home() {
        Map<String, Object> model = new HashMap<String, Object>();
        model.put("message", "Hello World!");
        return new JspView("home.jsp", model);
    }
}
{% endhighlight %}

		<p>Jsp - /WEB-INF/jsp/home.jsp <a href="{{ site.url }}{{ page.versionUrl }}/thundr/views.html#jspView">more</a></p>

{% highlight jsp %}
<%@ page contentType="text/html" pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" lang="en-us"/>
    </head>
    <body>
        ${message}
    </body>
</html>
{% endhighlight %}

		<p>Assuming that when you visit the url <code>http://localhost:8080/</code> thundr takes care of invoking your controller method, you would be served
			a page with the content &#39;Hello World!&#39;.</p>

		<p>We can see the basics of thundr and the three elements of the MVC interacting here:</p>
		<ul>
			<li>an incoming request is mapped to a controller using a <a
					href="{{ site.url }}{{ page.versionUrl }}/thundr/actions.html#routes">route</a></li>
			<li>Our <a href="{{ site.url }}{{ page.versionUrl }}/thundr/controllers.html">controller</a> method populates the <strong>model</strong>
				map with our message,
			</li>
			<li>which is then provided to our <a href="{{ site.url }}{{ page.versionUrl }}/thundr/views.html">view</a>, a JspView.</li>
			<li>thundr takes care of the rest, serving up our jsp as html, substituting the el variable ${message} with
				the text &#39;Hello World!&#39;.
			</li>
		</ul>

	</section>


	<section id="applicationConfiguration">
		<h4>Application Configuration</h4>

		<p>Beyond the basics of controller invocation and returning a view, there are several elements of configuration
			required for a thundr based application.</p>
		<ul>
			<li><a href="#webXml">web.xml</a> - configuring the thundr servlet</li>
			<li><a href="#applicationModule">ApplicationModule</a> - your dependency injection configuration</li>
			<li><a href="#routes">Routes</a> - configure url mappings to controllers</li>
			<li><a href="#applicationProperties">application properties</a> - your environmental properties</li>
		</ul>
	</section>

	<section id="webXml">
		<h4><code>webXml</code></h4>

		<p>The minimum web.xml required for a thundr app is to include the thundr servlet.</p>

{% highlight xml %}
<?xml version="1.0" encoding="UTF-8"?>
<web-app
    xmlns="http://java.sun.com/xml/ns/javaee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
    version="2.5">
    <servlet>
        <servlet-name>servlet</servlet-name>
        <servlet-class>com.threewks.thundr.ThundrServlet</servlet-class>
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>servlet</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>
</web-app>
{% endhighlight %}

		<p>Beyond this, you can use any servlets, servlet filters or other web.xml features you want. Remember that
			thundr is capable of invoking a servlet as a controller if you so wish. </p>
	</section>
	<section id="applicationModule">
		<h4><code>ApplicationModule</code></h4>
		
		<p>
			When your application starts up, you need to specify all the classes it will use. 
			Generally these are the controllers, service classes and repository/DAL classes.
		</p>
		<p>
			You do this in your <code>ApplicationModule</code> class. This is where you configure your dependency injection container
			(called the InjectionContext) so that thundr can invoke your controller methods. 
		</p>
		<p>
			thundr looks for your ApplicationModule in the default package (i.e. no package), and it must implement the 
			<code>com.threewks.thundr.injection.Module</code> interface.
		</p>
		
		<p>Below is a minimal ApplicationModule, which uses a base class, rather than the Module interface directly, and injects a sample controller, service dependency and configures a single route.</p>

{% highlight java %}
import com.threewks.thundr.injection.BaseModule;

public class ApplicationModule extends BaseModule {
	@Override
	public void configure(UpdatableInjectionContext injectionContext) {
		super.configure(injectionContext);
		injectionContext.inject(MyServiceImpl.class).as(MyServiceInterface.class);
		
		Routes routes = injectionContext.get(Routes.class);
		routes.addRoute(RouteType.GET, "/", null, new MethodAction(MyController.class, "home"));
	}
}

{% endhighlight %}
		
		<p>Components are contributed to thundr as <em>modules</em>. A module is defined as a group of code and a <code>Module</code> file which connects them together</p>
		<p>You application itself forms a module to make available all the instances and classes you wish to
			inject into your controllers and each-other.
			You can read more about modules <a href="{{ site.url }}{{ page.versionUrl }}/thundr/modules.html">here</a>
		</p>
	</section>


	<section id="routes">
		<h4>Routes</h4>
		
		<p>
			Routes control which controller method (or other action) is invoked when a request is served.
		</p>
		<p>
			Routes are added programatically during application startup in your ApplicationModule. By the time your ApplicationModule
			is invoked, thundr will have put many objects into your InjectionContext. One of these is the <code>com.threewks.thundr.route.Routes</code> object.
		</p>
		<p>
			This class is the central registry of where different requests get routed to in your application.
		</p>
		<p>
			You can simply call the <code>Routes.addRoute</code> method to add routes.
		</p>
{% highlight java %}
import com.threewks.thundr.injection.BaseModule;

public class ApplicationModule extends BaseModule {
  @Override
  public void configure(UpdatableInjectionContext injectionContext) {
    super.configure(injectionContext);
    // Get the routes out of the injection context
    Routes routes = injectionContext.get(Routes.class);
		
    // add desired routes
    routes.addRoute(RouteType.GET, "/", null, new MethodAction(MyController.class, "home"));
    routes.addRoute(RouteType.POST, "/", null, new MethodAction(MyController.class, "update"));
  }
}
{% endhighlight %}
	<p>
		A route consists of the following basic elements:
		<ul>
			<li><strong>RouteType</strong> - GET, PUT, POST, DELETE - the http method that this route should match</li>
			<li><strong>Route</strong> - the url pattern that this route should match</li>
			<li><strong>Name</strong> - routes can be named so that they can be easily referred to - this helps keep your application DRY</li>
			<li><strong>Action</strong> - if the route type and route match, this action will be executed. In the example above, a MethodAction results in a controller method being invoked</li>
		</ul>
		
		Read more about routes and actions <a href="actions.html">here</a>.
	</p>

	</section>
	
	<section id="applicationProperties">
		<h4><code>application.properties</code></h4>

		<p>thundr automatically loads properties from the <code>application.properties</code> file and puts them as
			named strings into the InjectionContext. This makes them available both in your ApplicationModule and
			also as constructor arguments to injected dependencies.</p>

		<p>This file is suitable for specifying configuration values that change per environment. That is, while your
			dependency configuration is generally environmentally agnostic, the application properties will generally not
			be. 
		</p>

		<p>This allows your built war file to be portable through environments without requiring rebuilding.</p>

{% highlight java %}
threadCount=20
threadCount%dev=2
serverUrl=localhost:8080
serverUrl%production=www.production.com
{% endhighlight %}

		<p>In the above example, all environments will have the properties <em>threadCount</em> and <em>serverUrl</em>
			injected into them, but the serverUrl for the environment named &#39;production&#39; will be different.</p>

		<blockquote>
			The environment named &#39;dev&#39; is special, in that it specifically applies to local development,
			rather than a target deployment environment.
		</blockquote>
	</section>
	<section id="platforms">
		<h4>Platforms</h4>

		<p>
			thundr can run on anywhere you can run a servlet container. 
		</p>
		<p>
			To configure the environment for different platforms, you need a platform <a href="modules.html">Module</a>.
			Minimally, all a platform module does is specify which environment (dev, test, uat, prod etc)
			the application is currently running in.
		</p>
		<p>
		Some platform modules, like <a href="{{ site.url }}{{ page.versionUrl }}/thundr-gae/">thundr-gae</a> expose more useful behaviour.
		</p>
		<blockquote>
			<p>
			thundr comes with a built in platform module <code>com.threewks.thundr.platform.DefaultPlatformModule</code>
			</p>
			<p>
				This configures the thundr environment using the system property <code>thundrEnvironment</code>, or if not present
				the environment variable with the same name.
			</p>
			<p>
			If you're running in a normal servlet container, just add this dependency in your ApplicationModule.
			</p>
			<p>
			You can then specify the system property either as an environment or container variable.
			</p>
		</blockquote>
		<p>
			If you don't want to use a platform module, be sure to set your environment at startup in your <code>ApplicationModule</code> in the
			initialise phase.
		</p>
{% highlight java %}
import com.threewks.thundr.injection.BaseModule;

public class ApplicationModule extends BaseModule {
...
	@Override
	public void initialise(UpdatableInjectionContext injectionContext) {
		super.initialise(injectionContext);
		Environment.set("environmentName");
	}
...
{% endhighlight %}		
	</section>
	<hr/>
	<section>
		Now that you know the basics, read more about <a href="controllers.html">Controllers</a>
	</section>
</article>
</div>
		